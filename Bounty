pragma solidity >=0.5.0 <0.6.0;

import "./ownable.sol";
import "./safemath.sol";

contract Bounty is Ownable {

  using SafeMath for uint256;
  using SafeMath32 for uint32;
  using SafeMath16 for uint16;

  event bountyCreated(string sponsor, string name, string description, uint expiration, string bounty_asset, uint bounty_quantity, string subject, uint difficulty, Response[] responses);
  event sufficientBalance(uint accountNum, string asset, uint quantity, boolean value);
   
    struct Vote {
    string voter;
    uint numVotes;
  }
  
    struct Response {
    string responder;
    string response;
    Vote[] votes;
  }
  
    struct Bounty {
    string sponsor;
    string name;
    string description;
    uint expiration;
    string bounty_asset;
    uint bounty_quantity;
    string subject;
    uint difficulty;
    Response[] responses;
  }
  
  Bounty[] public Bounties;

  modifier validBounty(uint _bountyNum) {
    require((_bountyNum > 0) && (_bountyNum < Bounties.length));
    _;
  }
  
  modifier validResponse(uint _bountyNum, uint _responseNum) {
    require((_bountyNum > 0) && (_bountyNum < Bounties.length) && (_responseNum > 0) && (_responseNum < Bounties[_bountyNum].responses.length));
    _;
  }

  function _createBounty(string _name, string _description, uint _expiration, string _bounty_asset, uint _bounty_quantity, string _subject, uint _difficulty, Response[] _responses) internal {
    Bounties.push(Bounty(msg.sender, _name, _description, _expiration, _bounty_asset, _bounty_quantity, _subject, _difficulty, _responses));
    emit bountyCreated(msg.sender, _name, _description, _expiration, _bounty_asset, _bounty_quantity, _subject, _difficulty, _responses); 
  }
}
    
    
    
