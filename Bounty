pragma solidity >=0.5.0 <0.6.0;

import "./Ownable.sol";
import "./safemath.sol";
import "./Account.sol";
import "./EDU.sol";

contract Bounty is Ownable {

  using SafeMath for uint256;
  using SafeMath32 for uint32;
  using SafeMath16 for uint16;

  event bountyCreated(string sponsor, string name, string description, uint expiration, string bounty_asset, uint bounty_quantity, string subject, uint difficulty, Response[] responses);
  event sufficientBalance(uint accountNum, string asset, uint quantity, boolean value);
   
    struct Vote {
    string voter;
    uint numVotes;
  }
  
    struct Response {
    string responder;
    string response;
    Vote[] votes;
  }
  
    struct Bounty {
    string sponsor;
    string name;
    string description;
    uint expiration;
    string bounty_asset;
    uint bounty_quantity;
    string subject;
    uint difficulty;
    Response[] responses;
  }
  
  Bounty[] public Bounties;

  modifier validBounty(uint _bountyNum) {
    require((_bountyNum > 0) && (_bountyNum < Bounties.length));
    _;
  }
  
  modifier validResponse(uint _bountyNum, uint _responseNum) {
    require((_bountyNum > 0) && (_bountyNum < Bounties.length) && (_responseNum > 0) && (_responseNum < Bounties[_bountyNum].responses.length));
    _;
  }
  
  modifier sufficientBalance(uint _accountNum, string _asset, uint _quantity) {
    require(validAccount(_accountNum));
    boolean sufficient = False;
    for (uint a = 0; a < Accounts[_accountNum].Wallet.length; a++) {
      if (keccak256(abi.encodePacked(Accounts[_accountNum].Wallet[a].Asset)) == keccak256(abi.encodePacked(_asset))) {
        sufficient = True;
        break;
      }
    }
    emit sufficientBalance(_accountNum, _asset, _quantity, sufficient);
    require(sufficient);
    _;
  }
  
  function _payOut(address payable _payee, uint _quantity) external onlyOwner {
    _transferFrom(_owner, _payee, _quantity);
  }

  function _createBounty(string _name, string _description, uint _expiration, string _bounty_asset, uint _bounty_quantity, string _subject, uint _difficulty, Response[] _responses) internal sufficientBalance(msg.sender, _bounty_asset, _bounty_quantity) payable {
    require(msg.value == 0.001 ether);
    Bounties.push(Bounty(msg.sender, _name, _description, _expiration, _bounty_asset, _bounty_quantity, _subject, _difficulty, _responses));
    emit bountyCreated(msg.sender, _name, _description, _expiration, _bounty_asset, _bounty_quantity, _subject, _difficulty, _responses); 
  }
}
    
    
    
