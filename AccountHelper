pragma solidity >=0.5.0 <0.6.0;

import "./BountyCreator.sol";

contract AccountHelper is Account {

  event verifiedAccount(uint accountNum, boolean value);
  event linkedAccount(uint accountNum, boolean value);
  
  mapping (uint => address) public accountOwner; 

  modifier verifiedAccount(uint _accountNum) {
      require(Accounts[_accountNum].student);
      _;
  }
  
  modifier linkedAccount(uint _accountNum) {
      require(accountOwner(_accountNum) != 0);
      _;
  }
  
  modifier isOwner(uint _accountNum) {
      require(keccak256(abi.encodePacked(msg.sender)) == keccak256(abi.encodePacked(accountOwner(_accountNum))));
      _;
  }
    
  function respond(uint _bountyNum, string _response) external {
    Vote[] initVotes = [];
    Response response = Response(msg.sender, _response, initVotes);
    Bounties[_bountyNum].responses.push(response);
    emit responseCreated(_bountyNum, Bounties[_bountyNum].responses.length - 1);
  }
  
  function closeBounty(uint _bountyNum) private {
    uint totalVotes = 0;
    uint winningVotes = 0;
    uint winningResponse = 0;
    
    for (uint r = 0; r < Bounties[_bountyNum].responses.length; r++) {
      uint currentVotes = 0;
      for (uint v = 0; v < Bounties[_bountyNum].responses[r].votes.length; v++) {
        currentVotes = currentVotes + Bounties[_bountyNum].responses[r].votes[v].numVotes;
      }
      if (currentVotes > winningVotes) {
        winningVotes = currentVotes;
        winningResponse = r;
      }
      totalVotes = totalVotes + currentVotes;
    }
    
    emit winningResponse(_bountyNum, winningResponse);
    
    //send bounty_amount bounty_asset to Bounties[_bountyNum].responses[r].responder
    
    for (uint v = 0; v < Bounties[_bountyNum].responses[winningResponse].votes.length; v++) {
      // send (totalVotes - winningVotes) * Bounties[_bountyNum].responses[winningResponse].votes[v].numVotes / winningVotes;
    }
  }

}
