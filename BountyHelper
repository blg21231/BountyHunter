pragma solidity >=0.5.0 <0.6.0;

import "./BountyCreator.sol";
import "./SafeMath.sol";
import "./EDU.sol";
import "./Account.sol";

contract BountyHelper is Bounty {

  event winningResponse(uint _bountyNum, uint _responseNum);
  event responseCreated(uint _bountyNum, uint _responseNum);

  modifier onlyOwnerOf(uint _bountyNum) {
      require(msg.sender == Bounties[_bountyNum].sponsor);
      _;
  }
  
  function getBounties(string _sortBy, boolean asc) external {
    if (_sortBy == 'expiration') {
    }
    elif (_sortBy == 'votes') {
    }
    elif (_sortBy == 'bounty_asset') {
    }
    elif (_sortBy == 'bounty_quantity') {
    }
  }
    
  function respond(uint _bountyNum, string _response) external payable {
    require((msg.value == 0.001 ether) || (sufficientBalance(msg.sender, "Credit for one free response", 1)) || (sufficientBalance(msg.sender, "EDU", 100)));
    if (msg.value != 0.001 ether) {
      uint EDU_index;
      for (a = 0; a < Accounts[msg.sender].wallet.length; a++) {
        if (Accounts[msg.sender].wallet[a].Asset == "Credit for one free response") {
          Accounts[msg.sender].wallet[a].Quantity = Accounts[msg.sender].wallet[a].Quantity - 1;
          break;
        }
        elif (Accounts[msg.sender].wallet[a].Asset == "EDU") {
        }
      
      }
    }
    Vote[] initVotes = [];
    Response response = Response(msg.sender, _response, initVotes);
    Bounties[_bountyNum].responses.push(response);
    emit responseCreated(_bountyNum, Bounties[_bountyNum].responses.length - 1);
  }
  
  function vote(uint _bountyNum, uint _responseNum) external payable {
    require(msg.value >= 0.001 ether);
    uint startingVotes = 0;
    for (uint v = 0; v < Bounties[_bountyNum].responses[_responseNum].votes.length; v++) {
      if (Bounties[_bountyNum].responses[_responseNum].votes[v].voter == msg.sender) {
        startingVotes = startingVotes + Bounties[_bountyNum].responses[_responseNum].votes[v].votes;
      }
    }
    uint votesPurchased = (2 * msg.value + startingVotes**2) ** (1/2);
    uint refund = msg.value - votesPurchased * 0.001;
    Vote vote = Vote(msg.sender, votesPurchased);
    Bounties[_bountyNum].responses.push(response);
    emit responseCreated(_bountyNum, Bounties[_bountyNum].responses.length - 1);
    msg.sender.transfer(refund);
  }
  
  function closeBounty(uint _bountyNum) private {
    uint totalVotes = 0;
    uint winningVotes = 0;
    uint winningResponse = 0;
    
    for (uint r = 0; r < Bounties[_bountyNum].responses.length; r++) {
      uint currentVotes = 0;
      for (uint v = 0; v < Bounties[_bountyNum].responses[r].votes.length; v++) {
        currentVotes = currentVotes + Bounties[_bountyNum].responses[r].votes[v].numVotes;
      }
      if (currentVotes > winningVotes) {
        winningVotes = currentVotes;
        winningResponse = r;
      }
      totalVotes = totalVotes + currentVotes;
    }
    
    emit winningResponse(_bountyNum, winningResponse);
    
    _mint(Bounties[_bountyNum].responses[r].responder, Bounties[_bountyNum].bounty_quantity);
    
    for (uint v = 0; v < Bounties[_bountyNum].responses[winningResponse].votes.length; v++) {
      _mint(Bounties[_bountyNum].responses[winningResponse].votes[v].voter, (totalVotes - winningVotes) * Bounties[_bountyNum].responses[winningResponse].votes[v].numVotes / winningVotes);
    }
  }

}
